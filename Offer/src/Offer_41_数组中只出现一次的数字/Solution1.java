/**
 *  AC!
 *  一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。
 *  要求时间复杂度O（n）,空间复杂度O（1）
 *  
   解题思路：
 首先我们考虑这个问题的一个简单版本：一个数组里除了一个数字之外，其他的数字都出现了两次。请写程序找出这个只出现一次的数字。
 这个题目的突破口在哪里？题目为什么要强调有一个数字出现一次，其他的出现两次？我们想到了异或运算的性质：任何一个数字异或它自己都等于0 。也就是说，如果我们从头到尾依次异或数组中的每一个数字，那么最终的结果刚好是那个只出现一次的数字，因为那些出现两次的数字全部在异或中抵消掉了。
 有了上面简单问题的解决方案之后，我们回到原始的问题。如果能够把原数组分为两个子数组。在每个子数组中，包含一个只出现一次的数字，而其它数字都出现两次。如果能够这样拆分原数组，按照前面的办法就是分别求出这两个只出现一次的数字了。
 我们还是从头到尾依次异或数组中的每一个数字，那么最终得到的结果就是两个只出现一次的数字的异或结果。因为其它数字都出现了两次，在异或中全部抵消掉了。由于这两个数字肯定不一样，那么这个异或结果肯定不为0 ，也就是说在这个结果数字的二进制表示中至少就有一位为1 。我们在结果数字中找到第一个为1 的位的位置，记为第N 位。现在我们以第N 位是不是1 为标准把原数组中的数字分成两个子数组，第一个子数组中每个数字的第N 位都为1 ，而第二个子数组的每个数字的第N 位都为0 。
 现在我们已经把原数组分成了两个子数组，每个子数组都包含一个只出现一次的数字，而其它数字都出现了两次。因此到此为止，所有的问题我们都已经解决。
*/
package Offer_41_数组中只出现一次的数字;
public class Solution1 {
	//num1,num2分别为长度为1的数组。传出参数
	//将num1[0],num2[0]设置为返回结果
    public void FindNumsAppearOnce(int [] array,int num1[] , int num2[]) {
    	if (array==null || array.length<2) {
			return;
		}
    	/**
    	 * 对整个数组进行异或运算，出现两次的数字就会消失，
    	 * 由于array中有两个数字不同，因此temp最后就等于这两个数字的异或值！
    	 */
    	int temp = 0;
    	for (int i = 0; i < array.length; i++) {
			temp ^= array[i];
		}
    	/**
    	 * 现在来求temp【从右向左】的第一次出现1的位置,由于是异或，所以temp的第一位为1的index就能够区分那两个只出现一次的数字。
    	 */
    	int index = this.firstOccur_1(temp);
    	/**
    	 * 现在凭借这个每个数字【从右向左】的第index位是不是1来把数字划分到两个数组中，并且保证出现两次的数字一定在同一个数组中，
    	 * 而只出现一次的两个数字一定不在同一个数组中，因为同一个数字的某一位一定是相同的，这就能保证同一个数字一定被划分到同一个数组
    	 * 而对于那两个不同的数字来说，由于我们上一步求出的index,这两个数字的第index位一定是不同的，
    	 * 所以可以保证那两个不同的数字可以被划分到不同的数组中！
    	 */
    	for (int i = 0; i < array.length; i++) {
			if (this.isBit(array[i], index)) {
				num1[0] ^= array[i];
			}else {
				num2[0] ^= array[i];
			}
		}
    	//System.out.println(num1[0]);
    	//System.out.println(num2[0]);
    }
    //寻找temp,【从右向左】，第一次出现1的位置.
    public int firstOccur_1(int temp) {
    	int index = 0;
    	while ((temp & 1)==0 && (index < 8<<2)) {
			temp = temp>>1;
    		index++;
		}
    	return index;
    }
    //来判断某个数字的index位是不是1,从而进行数组的划分
    public boolean isBit(int num, int index) {
    	num = num >> index;//num首先右移index位
    	return (num & 1)==1;
    }
    
    public static void main(String[] args) {
		Solution1 test = new Solution1();
		int[] array = {1,2,3,1,2,4};
		int[] num1 = new int[1];
		int[] num2 = new int[1];
		test.FindNumsAppearOnce(array, num1, num2);//011，100，111
		
		/**
		 * 先熟悉位于运算和左移，右移操作！
		 */
		//System.out.println(5 & 1);//&是按位与运算
		//System.out.println(5>>1); //>>右移一位，相当于处以2，5的二进制表示是101,右移一位，直接把最后一位去掉，就是10即2
		//System.out.println(6<<1); //<<左移一位，相当于乘于2，6的二进制表示是110，直接给最后补充个0，即1100，也就是12
    }
}